<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Slippi Profile Display</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      text-align: center;
      background-color: #121212;
      color: #ffffff;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background-color: #121212;
      padding: 20px;
      border: 1px solid #555;
      border-radius: 5px;
      box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.7);
    }
    .card {
      border: 1px solid #555;
      border-radius: 5px;
      padding: 15px;
      margin: 15px 0;
      background-color: #121212;
      box-shadow: 0px 8px 20px rgba(0,0,0,0.7);
    }
    h1, h2, h3, h4 {
      margin-top: 0;
    }
    canvas {
      max-width: 100%;
      height: 300px;
      margin-top: 10px;
    }
    p {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Slippi Profile: DMAR#554</h1>
    <div id="profile"></div>
  </div>

  <script>
    // -------------------------------
    // Custom Chart.js plugin to draw icons next to bars.
    // It uses the plugin option "barIconPlugin.icons" which should be an array of icon paths,
    // corresponding in order to the data points.
    // -------------------------------
    Chart.register({
      id: 'barIconPlugin',
      afterDatasetsDraw(chart, args, options) {
        const { ctx, chartArea: { left } } = chart;
        const datasetMeta = chart.getDatasetMeta(0);
        const icons = options.icons || [];
        datasetMeta.data.forEach((bar, index) => {
          const img = new Image();
          img.src = icons[index];
          // Once the image is loaded, draw it.
          // We draw it at a fixed size (20x20) to the left of the bar.
          const imageSize = 20;
          const xPos = left - imageSize - 5;
          const yPos = bar.y - imageSize / 2;
          // Draw the image when it has loaded.
          if (img.complete) {
            ctx.drawImage(img, xPos, yPos, imageSize, imageSize);
          } else {
            img.onload = () => {
              ctx.drawImage(img, xPos, yPos, imageSize, imageSize);
            };
          }
        });
      }
    });

    // -------------------------------
    // GraphQL endpoint and payload (for user DMAR#554)
    // -------------------------------
    const endpoint = "https://gql-gateway-2-dot-slippi.uc.r.appspot.com/graphql";
    const payload = {
      operationName: "AccountManagementPageQuery",
      query: `fragment profileFieldsV2 on NetplayProfileV2 {
  id
  ratingOrdinal
  ratingUpdateCount
  wins
  losses
  dailyGlobalPlacement
  dailyRegionalPlacement
  continent
  characters {
    character
    gameCount
    __typename
  }
  __typename
}

fragment userProfilePage on User {
  fbUid
  displayName
  connectCode {
    code
    __typename
  }
  status
  activeSubscription {
    level
    hasGiftSub
    __typename
  }
  rankedNetplayProfile {
    ...profileFieldsV2
    __typename
  }
  rankedNetplayProfileHistory {
    ...profileFieldsV2
    season {
      id
      startedAt
      endedAt
      name
      status
      __typename
    }
    __typename
  }
  __typename
}

query AccountManagementPageQuery($cc: String!, $uid: String!) {
  getUser(fbUid: $uid) {
    ...userProfilePage
    __typename
  }
  getConnectCode(code: $cc) {
    user {
      ...userProfilePage
      __typename
    }
    __typename
  }
}`,
      variables: { cc: "DMAR#554", uid: "DMAR#554" }
    };

    // -------------------------------
    // Helper: Format any all-caps, underscore-separated string into a display-friendly format.
    // For example, "NORTH_AMERICA" becomes "North America", "TIER1" becomes "Tier 1", etc.
    // -------------------------------
    function formatResponseData(text) {
      if (typeof text !== 'string') return text;
      return text
        .toLowerCase()
        .split('_')
        .map(word => {
          // Separate digits from letters if needed.
          // For example, "tier1" becomes "Tier 1".
          const match = word.match(/([a-z]+)(\d*)/);
          if (match) {
            return match[1].charAt(0).toUpperCase() + match[1].slice(1) + (match[2] ? ' ' + match[2] : '');
          }
          return word.charAt(0).toUpperCase() + word.slice(1);
        })
        .join(' ');
    }

    // -------------------------------
    // Helper: Get the icon filename based on the API character name.
    // Converts name to lowercase and replaces underscores with hyphens.
    // -------------------------------
    function getCharacterIcon(apiName) {
      return `icons/${apiName.toLowerCase().replace(/_/g, "-")}.png`;
    }

    // -------------------------------
    // Helper function to create a card element with a title and content.
    // -------------------------------
    function createCard(title, contentHTML) {
      const card = document.createElement('div');
      card.className = 'card';
      const header = document.createElement('h2');
      header.textContent = title;
      card.appendChild(header);
      const contentDiv = document.createElement('div');
      contentDiv.innerHTML = contentHTML;
      card.appendChild(contentDiv);
      return card;
    }

    // -------------------------------
    // Function to create a horizontal bar chart for character usage.
    // Parameters:
    //   canvasId: the ID of the canvas element where the chart is drawn.
    //   characters: an array of objects { character, gameCount }.
    // -------------------------------
    function createCharacterBarChart(canvasId, characters) {
      // Prepare arrays for labels, data, and icon paths.
      const labels = [];
      const data = [];
      const icons = [];
      characters.forEach(char => {
        labels.push(formatResponseData(char.character));
        data.push(char.gameCount);
        icons.push(getCharacterIcon(char.character));
      });

      const ctx = document.getElementById(canvasId).getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Games Played',
            data: data,
            backgroundColor: 'rgba(0, 123, 255, 0.7)',
            borderColor: 'rgba(0, 123, 255, 1)',
            borderWidth: 1
          }]
        },
        options: {
          indexAxis: 'y', // Horizontal bar chart.
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: { color: "#ffffff" },
              title: { display: true, text: 'Games', color: "#ffffff" }
            },
            y: {
              ticks: { color: "#ffffff" }
            }
          },
          plugins: {
            legend: {
              labels: { color: "#ffffff" }
            },
            // Pass the icons array to our custom plugin.
            barIconPlugin: {
              icons: icons
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  return `${context.label}: ${context.parsed.x} games`;
                }
              }
            }
          }
        }
      });
    }

    // -------------------------------
    // Function to render the user profile data.
    // For each season (in rankedNetplayProfileHistory), if character data exists,
    // replace the character list with a bar chart.
    // -------------------------------
    function renderUserProfile(user) {
      const profileContainer = document.getElementById('profile');
      if (!user) {
        profileContainer.textContent = 'No user data found.';
        return;
      }

      // Basic Information
      let basicHTML = `
        <p><strong>Name:</strong> ${user.displayName}</p>
        <p><strong>Connect Code:</strong> ${user.connectCode.code}</p>
        <p><strong>Status:</strong> ${formatResponseData(user.status)}</p>
        <p><strong>Subscription:</strong> ${formatResponseData(user.activeSubscription.level)} ${user.activeSubscription.hasGiftSub ? '(Gifted)' : ''}</p>
      `;
      profileContainer.appendChild(createCard("Basic Information", basicHTML));

      // Ranked Netplay Profile
      if (user.rankedNetplayProfile) {
        let profile = user.rankedNetplayProfile;
        let profileHTML = `
          <p><strong>Rating:</strong> ${profile.ratingOrdinal.toFixed(2)}</p>
          <p><strong>Rating Updates:</strong> ${profile.ratingUpdateCount}</p>
          <p><strong>Wins:</strong> ${profile.wins}</p>
          <p><strong>Losses:</strong> ${profile.losses}</p>
          <p><strong>Continent:</strong> ${formatResponseData(profile.continent)}</p>
        `;
        // List characters used (for the main profile, we still show the icons & counts as a list).
        if (profile.characters && profile.characters.length > 0) {
          profileHTML += `<h3>Characters</h3><div>`;
          profile.characters.forEach(char => {
            const displayName = formatResponseData(char.character);
            const iconPath = getCharacterIcon(char.character);
            profileHTML += `<div style="display:inline-block; margin:5px; padding:5px; background:#222; border-radius:3px;">
              <img src="${iconPath}" alt="${displayName} icon" style="width:20px;height:20px;vertical-align:middle; margin-right:3px;" onerror="this.style.display='none'">
              ${displayName}: ${char.gameCount} games
            </div>`;
          });
          profileHTML += `</div>`;
        }
        profileContainer.appendChild(createCard("Ranked Netplay Profile", profileHTML));
      }

      // Ranked Netplay Profile History
      if (user.rankedNetplayProfileHistory && user.rankedNetplayProfileHistory.length > 0) {
        user.rankedNetplayProfileHistory.forEach(history => {
          let season = history.season;
          // Build the season details.
          let historyHTML = `
            <p><strong>Season:</strong> ${season.name} (${formatResponseData(season.status)})</p>
            <p><strong>Period:</strong> ${new Date(season.startedAt).toLocaleDateString()} - ${new Date(season.endedAt).toLocaleDateString()}</p>
            <p><strong>Rating:</strong> ${history.ratingOrdinal.toFixed(2)}</p>
            <p><strong>Rating Updates:</strong> ${history.ratingUpdateCount}</p>
            <p><strong>Wins:</strong> ${history.wins}</p>
            <p><strong>Losses:</strong> ${history.losses}</p>
            <p><strong>Continent:</strong> ${formatResponseData(history.continent)}</p>
          `;
          // If there is character data for this season, insert a canvas for the bar chart.
          if (history.characters && history.characters.length > 0) {
            // Use season.id (or index) to create a unique canvas id.
            const canvasId = "chart-" + season.id;
            historyHTML += `<h4>Character Usage</h4><canvas id="${canvasId}"></canvas>`;
          }
          // Create the card for this season and append it.
          const card = createCard(`Ranked Netplay History - ${season.name}`, historyHTML);
          profileContainer.appendChild(card);
          // If a canvas was inserted, create the bar chart.
          if (history.characters && history.characters.length > 0) {
            const canvasId = "chart-" + season.id;
            // Create the bar chart for this season's character usage.
            createCharacterBarChart(canvasId, history.characters);
          }
        });
      }
    }

    // -------------------------------
    // Fetch data and render it on the page.
    // -------------------------------
    fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    })
      .then(response => response.json())
      .then(data => {
        const user = data.data.getUser || (data.data.getConnectCode && data.data.getConnectCode.user);
        renderUserProfile(user);
      })
      .catch(error => {
        document.getElementById('profile').textContent = 'Error: ' + error;
      });
  </script>
</body>
</html>
