<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Boba's Boomputer Leaderboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
    body { font-family: 'Roboto', sans-serif; text-align: center; background-color: #121212; color: #ffffff; margin: 0; padding: 0; }
    .tabs { margin: 20px auto; display: inline-block; }
    .tab { display: inline-block; padding: 10px 20px; cursor: pointer; border: 1px solid #555; border-bottom: none; background-color: #555; margin-right: 2px; box-shadow: 0px 8px 20px rgba(0,0,0,0.7); }
    .tab.active { background-color: #121212; font-weight: bold; border-bottom: 1px solid #121212; }
    .tabContent { display: none; max-width: 800px; margin: 20px auto; border: 1px solid #555; background-color: #121212; padding: 10px; box-shadow: 0px 8px 20px rgba(0,0,0,0.7); }
    .tabContent.active { display: block; }
    table { margin: 20px auto; width: 90%; max-width: 800px; border-collapse: collapse; box-shadow: 0px 8px 20px rgba(0,0,0,0.7); }
    th, td { padding: 10px 15px; border: 1px solid #555; }
    th { background-color: #222; }
    td { background-color: #121212; }
    .gray { color: #999; }
    .hidden { display: none; }
    .toggle-container { margin: 10px 0; }
    .toggle-container label { font-size: 14px; cursor: pointer; }
    .chart-container { width: 800px; height: 400px; margin: 20px auto; position: relative; }
    canvas { display: block; width: 100% !important; height: 100% !important; background: #222; box-shadow: 0px 8px 20px rgba(0,0,0,0.7); }
  </style>
</head>
<body>
  <h1>Boba's Boomputer Leaderboard</h1>
  <div class="tabs">
    <span class="tab active" onclick="showTab('leaderboard')">Leaderboard</span>
    <span class="tab" onclick="showTab('recordProgression')">Record Progression</span>
    <span class="tab" onclick="showTab('pbProgression')">PB Progression</span>
    <span class="tab" onclick="showTab('allRuns')">All Runs</span>
  </div>
  <div class="global-toggle">
    <label>
      <input type="checkbox" id="toggleRemix" onchange="toggleRemixCharacters()">
      Include Remix Characters
    </label>
  </div>
  <div id="leaderboard" class="tabContent active">
    <label><input type="checkbox" id="toggleObsolete" onchange="toggleObsolete()" /> Show Obsoleted Runs</label>
    <table>
      <thead>
        <tr>
          <th>Rank</th>
          <th>Player</th>
          <th>Character</th>
          <th>Score</th>
          <th>Date</th>
        </tr>
      </thead>
      <tbody id="leaderboard-body"></tbody>
    </table>
  </div>
  <div id="recordProgression" class="tabContent">
    <div class="chart-container">
      <canvas id="recordChart"></canvas>
    </div>
  </div>
  <div id="pbProgression" class="tabContent">
    <div class="toggle-container">
      <label><input type="checkbox" id="toggleSinglePB" checked onchange="toggleSinglePointPB()" /> Show players with 1 run</label>
    </div>
    <div class="chart-container">
      <canvas id="pbChart"></canvas>
    </div>
  </div>
  <div id="allRuns" class="tabContent">
    <div class="toggle-container">
      <label><input type="checkbox" id="toggleSingleAll" checked onchange="toggleSinglePointAll()" /> Show players with 1 run</label>
    </div>
    <div class="chart-container">
      <canvas id="allRunsChart"></canvas>
    </div>
  </div>
  <script>
    let runs = [];
    let bestRuns = {};
    let recordChartInitialized = false, pbChartInitialized = false, allRunsChartInitialized = false;
    let recordChart = null, pbChart = null, allRunsChart = null;
    const playerColors = {};
    let showSinglePB = true, showSingleAll = true;
    let lastHue = Math.random();
    // Characters that are **kept** when Remix is excluded (vanilla-only list)
    const vanillaCharacters = new Set([
      'Pika','Yoshi','Falcon','Kirby','Puff','Fox','Mario','Ness','DK','Luigi','Link','Samus'
    ]);
    // Global state for the new toggle (OFF by default)
    let includeRemix = false;
    // Helper: whether a runâ€™s character is allowed under current toggle
    function isAllowedCharacter(char) {
      return includeRemix ? true : vanillaCharacters.has(char);
    }
    // Filtered view of runs based on the toggle
    function getFilteredRuns() {
      return runs.filter(r => isAllowedCharacter(r.character));
    }
    // Compute best run per player for a given list (used for obsolete shading)
    function computeBestRuns(list) {
      const map = {};
      list.forEach(run => {
        const score = parseInt(run.score, 10);
        if (!map[run.player] || score > parseInt(map[run.player].score, 10)) {
          map[run.player] = run;
        }
      });
      return map;
    }
    // Toggle handler
    function toggleRemixCharacters() {
      includeRemix = document.getElementById('toggleRemix').checked;
      // Re-render leaderboard
      renderLeaderboard(runs);
      // Update charts if already initialized
      if (recordChartInitialized) updateRecordProgressionChart();
      if (pbChartInitialized)     updatePBProgressionChart();
      if (allRunsChartInitialized)updateAllRunsChart();
    }
    function getDistinctColor() {
      const goldenRatioConjugate = 0.618033988749895;
      lastHue = (lastHue + goldenRatioConjugate) % 1;
      return `hsl(${Math.floor(lastHue * 360)}, 100%, 60%)`;
    }
    function showTab(tabName) {
      document.querySelectorAll(".tabContent").forEach(tab => tab.classList.remove("active"));
      document.getElementById(tabName).classList.add("active");
      document.querySelectorAll(".tab").forEach(button => button.classList.remove("active"));
      document.querySelector(`.tab[onclick="showTab('${tabName}')"]`).classList.add("active");
      if (tabName === 'recordProgression' && !recordChartInitialized) { updateRecordProgressionChart(); recordChartInitialized = true; }
      else if (tabName === 'recordProgression' && recordChart) { updateRecordProgressionChart(); }
      if (tabName === 'pbProgression' && !pbChartInitialized) { updatePBProgressionChart(); pbChartInitialized = true; }
      else if (tabName === 'pbProgression' && pbChart) { updatePBProgressionChart(); }
      if (tabName === 'allRuns' && !allRunsChartInitialized) { updateAllRunsChart(); allRunsChartInitialized = true; }
      else if (tabName === 'allRuns' && allRunsChart) { updateAllRunsChart(); }
    }
    async function fetchLeaderboardData() {
      try { const response = await fetch('leaderboard.json'); const data = await response.json(); processAndRenderData(data.runs); }
      catch (error) { console.error("Error loading leaderboard data:", error); }
    }
    function processAndRenderData(runsData) {
      // keep numeric comparisons stable by padding, like you already do
      runsData.forEach(run => {
        run.score = run.score.toString().padStart(8, '0');
      });
      // sort descending by numeric score
      runsData.sort((a, b) => parseInt(b.score, 10) - parseInt(a.score, 10));
      runs = runsData;
      renderLeaderboard(runs);
    }
    function renderLeaderboard(allRuns) {
      const showObsolete = document.getElementById("toggleObsolete").checked;
      // Filter by character setting
      const visibleRuns = getFilteredRuns();
      // Best runs **within the filtered set**
      const bestByPlayer = computeBestRuns(visibleRuns);
      // Build rows **only** from filtered runs
      let rowsHtml = "";
      visibleRuns.forEach(run => {
        const isBestRun = bestByPlayer[run.player] && bestByPlayer[run.player].score === run.score;
        const rowClass = !isBestRun ? 'gray' : '';
        const rowHidden = (!isBestRun && !showObsolete) ? 'hidden' : '';
        const [yyyy, mm, dd] = run.timestamp.split("-");
        const formattedDate = `${mm}/${dd}/${yyyy.slice(2)}`;
        rowsHtml += `<tr class="${rowClass} ${rowHidden}"><td></td><td>${run.player}</td><td>${run.character}</td><td>${run.score}</td><td>${formattedDate}</td></tr>`;
      });
      document.getElementById("leaderboard-body").innerHTML = rowsHtml;
      updateRanks();
    }
    function updateRanks() {
      let rank = 1;
      document.querySelectorAll("#leaderboard-body tr").forEach(row => { if (!row.classList.contains('hidden')) row.cells[0].innerText = '#' + rank++; });
    }
    function updateRecordProgressionChart() {
      const filtered = getFilteredRuns().slice().sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      let recordProgression = [], currentRecord = 0;
      filtered.forEach(run => {
        const score = parseInt(run.score, 10);
        if (score > currentRecord) {
          currentRecord = score;
          recordProgression.push(run);
        }
      });
      const chartData = recordProgression.map(run => ({
        x: new Date(run.timestamp),
        y: parseInt(run.score, 10),
        run
      }));
      if (!recordChart) {
        const ctx = document.getElementById('recordChart').getContext('2d');
        recordChart = new Chart(ctx, {
          type: 'line',
          data: { datasets: [{ label: 'Record Progression', data: chartData, fill: false, borderColor: 'blue', tension: 0, pointRadius: 5, pointHoverRadius: 7 }] },
          options: {
            responsive: true, maintainAspectRatio: true,
            scales: {
              x: { type: 'time', time: { unit: 'year', displayFormats: { year: 'yyyy' }, tooltipFormat: 'MM/dd/yy' }, title: { display: true, text: 'Year', color: "#ffffff" }, ticks: { color: "#ffffff" } },
              y: { title: { display: true, text: 'Score', color: "#ffffff" }, ticks: { color: "#ffffff" } }
            },
            plugins: { legend: { labels: { color: "#ffffff" } }, tooltip: { callbacks: { label: (ctx) => { const run = ctx.raw.run; return `${run.player} | ${run.character} | ${run.score}`; } } } }
          }
        });
      } else {
        recordChart.data.datasets[0].data = chartData;
        recordChart.update();
      }
    }
    function updatePBProgressionChart() {
      const filtered = getFilteredRuns();
      const pbProgressions = {};
      filtered.forEach(run => {
        if (!pbProgressions[run.player]) pbProgressions[run.player] = [];
        pbProgressions[run.player].push(run);
      });
      const datasets = [];
      for (const player in pbProgressions) {
        const playerRuns = pbProgressions[player].slice().sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        const progression = [];
        let currentPB = 0;
        playerRuns.forEach(run => {
          const score = parseInt(run.score, 10);
          if (score > currentPB) {
            currentPB = score;
            progression.push({ x: new Date(run.timestamp), y: score, run });
          }
        });
        if (!(progression.length === 1 && !showSinglePB)) {
          if (!playerColors[player]) playerColors[player] = getDistinctColor();
          datasets.push({ label: player, data: progression, fill: false, borderColor: playerColors[player], tension: 0, pointRadius: 5, pointHoverRadius: 7 });
        }
      }
      if (!pbChart) {
        const ctx = document.getElementById('pbChart').getContext('2d');
        pbChart = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true, maintainAspectRatio: true,
            scales: {
              x: { type: 'time', time: { unit: 'year', displayFormats: { year: 'yyyy' }, tooltipFormat: 'MM/dd/yy' }, title: { display: true, text: 'Year', color: "#ffffff" }, ticks: { color: "#ffffff" } },
              y: { title: { display: true, text: 'Score', color: "#ffffff" }, ticks: { color: "#ffffff" } }
            },
            plugins: { legend: { labels: { color: "#ffffff" } }, tooltip: { callbacks: { label: (ctx) => { const run = ctx.raw.run; return `${run.player} | ${run.character} | ${run.score}`; } } } }
          }
        });
      } else {
        pbChart.data.datasets = datasets;
        pbChart.update();
      }
    }
    function updateAllRunsChart() {
      const filtered = getFilteredRuns();
      const allRunsByPlayer = {};
      filtered.forEach(run => {
        if (!allRunsByPlayer[run.player]) allRunsByPlayer[run.player] = [];
        allRunsByPlayer[run.player].push(run);
      });
      const datasets = [];
      for (const player in allRunsByPlayer) {
        const playerRuns = allRunsByPlayer[player].slice().sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        const allData = playerRuns.map(run => ({ x: new Date(run.timestamp), y: parseInt(run.score, 10), run }));
        if (!(allData.length === 1 && !showSingleAll)) {
          if (!playerColors[player]) playerColors[player] = getDistinctColor();
          datasets.push({ label: player, data: allData, fill: false, borderColor: playerColors[player], tension: 0, pointRadius: 5, pointHoverRadius: 7 });
        }
      }
      if (!allRunsChart) {
        const ctx = document.getElementById('allRunsChart').getContext('2d');
        allRunsChart = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true, maintainAspectRatio: true,
            scales: {
              x: { type: 'time', time: { unit: 'year', displayFormats: { year: 'yyyy' }, tooltipFormat: 'MM/dd/yy' }, title: { display: true, text: 'Year', color: "#ffffff" }, ticks: { color: "#ffffff" } },
              y: { title: { display: true, text: 'Score', color: "#ffffff" }, ticks: { color: "#ffffff" } }
            },
            plugins: { legend: { labels: { color: "#ffffff" } }, tooltip: { callbacks: { label: (ctx) => { const run = ctx.raw.run; return `${run.player} | ${run.character} | ${run.score}`; } } } }
          }
        });
      } else {
        allRunsChart.data.datasets = datasets;
        allRunsChart.update();
      }
    }
    function toggleSinglePointPB() { showSinglePB = document.getElementById("toggleSinglePB").checked; if (pbChartInitialized) updatePBProgressionChart(); }
    function toggleSinglePointAll() { showSingleAll = document.getElementById("toggleSingleAll").checked; if (allRunsChartInitialized) updateAllRunsChart(); }
    function toggleObsolete() { renderLeaderboard(runs); }
    fetchLeaderboardData();
  </script>
</body>
</html>
